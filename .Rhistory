kronecker_icm <- function(B, Kx, eta) {
K <- kronecker(B, Kx)
P <- nrow(Kx); M <- length(eta)
K <- K + diag(rep(eta, each=P))
K
}
pack_L <- function(L) L[lower.tri(L, diag=TRUE)]
unpack_L <- function(theta, m) {
L <- matrix(0, m, m)
L[lower.tri(L, diag=TRUE)] <- theta
diag(L) <- abs(diag(L)) + 1e-8
L
}
# ------------------------ Wavelet wrappers (waveslim) ------------------------
# DWT flatten (d1,...,dJ,sJ), save indices per level for per-level scales
wt_forward_1d <- function(y, wf="la8", J=NULL, boundary="periodic") {
P <- length(y)
if (is.null(J)) J <- floor(log2(P))
if (abs(P - 2^J) > 0) stop("Series length P must be 2^J (dyadic) for the DWT.")
w <- dwt(y, wf=wf, n.levels=J, boundary=boundary)
vec <- c(w$d1)
idx <- list(d1 = seq_along(w$d1))
off <- length(w$d1)
for (lev in 2:J) {
v <- w[[paste0("d",lev)]]
vec <- c(vec, v)
idx[[paste0("d",lev)]] <- (off+1):(off+length(v))
off <- off + length(v)
}
vec <- c(vec, w[[paste0("s",J)]])
idx[[paste0("s",J)]] <- (off+1):(off+length(w[[paste0("s",J)]]))
list(coeff=vec, map=list(J=J, wf=wf, boundary=boundary, P=P, idx=idx))
}
wt_inverse_1d <- function(coeff_vec, map) {
J <- map$J
w <- list()
for (lev in 1:J) w[[paste0("d",lev)]] <- coeff_vec[ map$idx[[paste0("d",lev)]] ]
w[[paste0("s",J)]] <- coeff_vec[ map$idx[[paste0("s",J)]] ]
# idwt(w)  # <-- FIX: waveslim::idwt does not take wf/boundary args
attr(w, "wavelet")  <- map$wf
attr(w, "boundary") <- map$boundary
class(w) <- "dwt"
idwt(w)
}
wt_forward_mat <- function(y_mat, wf="la8", J=NULL, boundary="periodic") {
P <- nrow(y_mat); M <- ncol(y_mat)
out <- vector("list", M)
for (m in 1:M) out[[m]] <- wt_forward_1d(y_mat[,m], wf=wf, J=J, boundary=boundary)
out
}
wt_inverse_mat_keep <- function(y_mat, wtf_list, gamma_list) {
P <- nrow(y_mat); M <- ncol(y_mat)
y_norm <- matrix(0, P, M)
for (m in 1:M) {
cvec <- wtf_list[[m]]$coeff
gvec <- gamma_list[[m]]
cvec[gvec == 0] <- 0
y_norm[,m] <- wt_inverse_1d(cvec, wtf_list[[m]]$map)
}
y_norm
}
wt_stack_channel <- function(Y_list, wf="la8", J=NULL, boundary="periodic") {
M <- ncol(Y_list[[1]]); P <- nrow(Y_list[[1]]); N <- length(Y_list)
tmp <- wt_forward_mat(Y_list[[1]], wf=wf, J=J, boundary=boundary)
ncoeff <- length(tmp[[1]]$coeff)
D_arr <- array(NA_real_, dim=c(ncoeff, N, M))
for (i in 1:N) {
wtf <- wt_forward_mat(Y_list[[i]], wf=wf, J=J, boundary=boundary)
for (m in 1:M) D_arr[,i,m] <- wtf[[m]]$coeff
}
list(D_arr=D_arr, maps=tmp)  # maps per channel
}
# ---------------- Wavelet spike-and-slab with PER-LEVEL scales ---------------
# wpar[[m]] = list(pi, g, sigma2_level (named vector per level), gamma (per coeff))
# Hyperparameters:
#   pi ~ Beta(a_pi, b_pi), g ~ IG(a_g,b_g), for each level l: sigma2_l ~ IG(a_s,b_s)
# Spike variance at level l is c0 * sigma2_l (c0 small)
update_wavelet_params <- function(Y_list, wf, J, boundary, wpar,
a_pi=1, b_pi=1, a_g=2, b_g=1, a_s=2, b_s=1, c0=1e-3) {
M <- ncol(Y_list[[1]]); N <- length(Y_list)
st <- wt_stack_channel(Y_list, wf=wf, J=J, boundary=boundary)
D_arr <- st$D_arr
new <- wpar
for (m in 1:M) {
ncoeff <- dim(D_arr)[1]
N      <- dim(D_arr)[2]      # ensure N matches the stacked coeffs
D      <- matrix(D_arr[ , , m], nrow = ncoeff, ncol = N)
map_m <- st$maps[[m]]$map
lev_names <- names(map_m$idx)      # e.g., "d1","d2",...,"sJ"
# ncoeff <- nrow(D)
# Build per-coeff sigma2 vector from per-level values
# Initialize missing sigma2_level if not set yet
if (is.null(wpar[[m]]$sigma2_level)) {
sigma2_level <- setNames(rep(1.0, length(lev_names)), lev_names)
} else {
sigma2_level <- wpar[[m]]$sigma2_level
# add any missing names (first iteration)
for (nm in setdiff(lev_names, names(sigma2_level))) sigma2_level[nm] <- 1.0
sigma2_level <- sigma2_level[lev_names]
}
s2_vec <- numeric(ncoeff)
for (nm in lev_names) s2_vec[ map_m$idx[[nm]] ] <- sigma2_level[nm]
# Current pi, g
pi  <- wpar[[m]]$pi
g   <- wpar[[m]]$g
# Log-likelihood rows with per-coeff sd: slab has sd = sqrt(g*s2_j), spike: sqrt(c0*s2_j)
# compute row-wise log-lik across curves
log_slab  <- rowSums( do.call(cbind, lapply(1:N, function(i) dnorm(D[,i], 0, sqrt(g*s2_vec), log=TRUE))) )
log_spike <- rowSums( do.call(cbind, lapply(1:N, function(i) dnorm(D[,i], 0, sqrt(c0*s2_vec), log=TRUE))) )
logit_p   <- log(pi) + log_slab - (log(1-pi) + log_spike)
p1        <- plogis(logit_p)
gamma     <- rbinom(ncoeff, 1, p1)
# Update g | slab coeffs (note per-coeff s2 enters denominator)
idx_slab <- which(gamma==1)
ss_over_s2 <- if (length(idx_slab)>0) {
sum( rowSums(D[idx_slab,,drop=FALSE]^2) / s2_vec[idx_slab] )
} else 0
post_a_g <- a_g + 0.5 * length(idx_slab) * N
post_b_g <- b_g + 0.5 * ss_over_s2
g   <- rinvgamma(1, post_a_g, max(post_b_g, 1e-12))
# Update pi
pi  <- rbeta(1, a_pi + sum(gamma), b_pi + (ncoeff - sum(gamma)))
# Update per-LEVEL sigma2_l using slab/spike decomposition
for (nm in lev_names) {
ids <- map_m$idx[[nm]]
n_l <- length(ids)
if (n_l == 0) next
# sums across curves
ss_slab  <- if (any(gamma[ids]==1)) sum( rowSums(D[ids[gamma[ids]==1],,drop=FALSE]^2) ) else 0
ss_spike <- if (any(gamma[ids]==0)) sum( rowSums(D[ids[gamma[ids]==0],,drop=FALSE]^2) ) else 0
# Posterior for sigma2_l under mixture:
#   slab term contributes ss_slab / g, spike contributes ss_spike / c0
post_a_s <- a_s + 0.5 * N * n_l
post_b_s <- b_s + 0.5 * ( ss_slab / max(g,1e-12) + ss_spike / max(c0,1e-12) )
sigma2_level[nm] <- rinvgamma(1, post_a_s, max(post_b_s, 1e-12))
}
new[[m]] <- list(pi=pi, g=g, sigma2_level=sigma2_level, gamma=gamma)
}
list(wpar=new, maps=st$maps)
}
reconstruct_normals_for_cluster <- function(Y_list, wf, J, boundary, wpar) {
N <- length(Y_list); P <- nrow(Y_list[[1]]); M <- ncol(Y_list[[1]])
out <- vector("list", N)
for (i in 1:N) {
wtf <- wt_forward_mat(Y_list[[i]], wf=wf, J=J, boundary=boundary)
gam <- lapply(wpar, function(wm) wm$gamma)
out[[i]] <- wt_inverse_mat_keep(Y_list[[i]], wtf, gam)
}
out
}
# ------------------------ Likelihood & MH updates ----------------------------
loglik_icm <- function(y_norm, t, L, eta, kern_cfg, kp) {
B  <- tcrossprod(L)
Kx <- kern_cfg$fun(t, kp)
K  <- kronecker_icm(B, Kx, eta)
yv <- as.numeric(y_norm)
chol_loglik(yv, K, jitter=1e-6)$ll
}
mh_update_kernel <- function(kern_cfg, kp, t, Ynorm_list, L, eta, acc) {
for(pn in kern_cfg$pnames) {
cur <- kp[[pn]]
if (pn == "period") {
z_cur <- logit(pmin(pmax(cur,1e-6), 1-1e-6))
z_prp <- rnorm(1, z_cur, kern_cfg$prop_sd[[pn]])
prp   <- invlogit(z_prp)
kp_prop <- kp; kp_prop[[pn]] <- prp
ll_cur <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L, eta=eta, kern_cfg=kern_cfg, kp=kp))
ll_prp <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L, eta=eta, kern_cfg=kern_cfg, kp=kp_prop))
lp_cur <- kern_cfg$prior(kp)
lp_prp <- kern_cfg$prior(kp_prop)
a <- (ll_prp + lp_prp) - (ll_cur + lp_cur) # symmetric RW in z
if (is.finite(a) && log(runif(1)) < a) { kp <- kp_prop; acc$kern <- acc$kern + 1 }
} else {
prp   <- rlnorm(1, log(cur), kern_cfg$prop_sd[[pn]])
kp_prop <- kp; kp_prop[[pn]] <- prp
ll_cur <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L, eta=eta, kern_cfg=kern_cfg, kp=kp))
ll_prp <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L, eta=eta, kern_cfg=kern_cfg, kp=kp_prop))
lp_cur <- kern_cfg$prior(kp)
lp_prp <- kern_cfg$prior(kp_prop)
q_cgpr <- dlnorm(cur, log(prp), kern_cfg$prop_sd[[pn]], log=TRUE)
q_prgc <- dlnorm(prp, log(cur), kern_cfg$prop_sd[[pn]], log=TRUE)
a <- (ll_prp + lp_prp + q_cgpr) - (ll_cur + lp_cur + q_prgc)
if (is.finite(a) && log(runif(1)) < a) { kp <- kp_prop; acc$kern <- acc$kern + 1 }
}
}
list(kp=kp, acc=acc)
}
mh_update_L <- function(L, step, t, Ynorm_list, eta, kern_cfg, kp, acc) {
th  <- pack_L(L)
thp <- th + rnorm(length(th), 0, step)
Lp  <- unpack_L(thp, nrow(L))
ll_cur <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L,  eta=eta, kern_cfg=kern_cfg, kp=kp))
ll_prp <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=Lp, eta=eta, kern_cfg=kern_cfg, kp=kp))
lp_cur <- sum(dnorm(th,  0, 1, log=TRUE))
lp_prp <- sum(dnorm(thp, 0, 1, log=TRUE))
a <- (ll_prp + lp_prp) - (ll_cur + lp_cur)
if (is.finite(a) && log(runif(1)) < a) { L <- Lp; acc$L <- acc$L + 1 }
list(L=L, acc=acc)
}
mh_update_eta <- function(eta, step, t, Ynorm_list, L, kern_cfg, kp, acc) {
for(j in seq_along(eta)) {
cur <- eta[j]
prp <- rlnorm(1, log(cur), step)
etap <- eta; etap[j] <- prp
ll_cur <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L, eta=eta,  kern_cfg=kern_cfg, kp=kp))
ll_prp <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L, eta=etap, kern_cfg=kern_cfg, kp=kp))
lp_cur <- dinvgamma(cur, 2, 0.1, log=TRUE)
lp_prp <- dinvgamma(prp, 2, 0.1, log=TRUE)
q_cgpr <- dlnorm(cur, log(prp), step, log=TRUE)
q_prgc <- dlnorm(prp, log(cur), step, log=TRUE)
a <- (ll_prp + lp_prp + q_cgpr) - (ll_cur + lp_cur + q_prgc)
if (is.finite(a) && log(runif(1)) < a) { eta <- etap; acc$eta <- acc$eta + 1 }
}
list(eta=eta, acc=acc)
}
# ------------------------ Carlinâ€“Chib kernel switch --------------------------
cc_switch_kernel <- function(kern_list, cur_idx, thetas, t, Ynorm_list, L, eta) {
Mmod <- length(kern_list)
p_m  <- rep(1/Mmod, Mmod)
theta_draws <- vector("list", Mmod)
for(m in 1:Mmod) theta_draws[[m]] <- if(m==cur_idx) thetas[[m]] else kern_list[[m]]$pstar()
logw <- rep(NA_real_, Mmod)
for(m in 1:Mmod) {
kc <- kern_list[[m]]; kp <- theta_draws[[m]]
ll_m <- sum(sapply(Ynorm_list, loglik_icm, t=t, L=L, eta=eta, kern_cfg=kc, kp=kp))
rest <- sum(sapply(setdiff(1:Mmod, m), function(j) {
th <- theta_draws[[j]]
if(kern_list[[j]]$name == "Periodic") {
dgamma(th$l_scale, 3, 2, log=TRUE) + dbeta(th$period, 5, 5, log=TRUE)
} else {
dgamma(th$l_scale, 2, 2, log=TRUE)
}
}))
logw[m] <- log(p_m[m]) + ll_m + rest
}
w <- exp(logw - max(logw)); w <- w / sum(w)
new_idx <- sample.int(Mmod, 1, prob = w)
list(idx=new_idx, thetas=theta_draws, weights=w)
}
# ------------------------ Walker slice sampler (retrospective) ---------------
stick_to_pi <- function(v) {
K <- length(v)
pi <- numeric(K); cum <- 1
for(k in 1:K) { pi[k] <- v[k] * cum; cum <- cum * (1 - v[k]) }
pi
}
extend_sticks_until <- function(v, alpha, threshold) {
tail <- prod(1 - v)
while (tail > threshold) {
v_new <- rbeta(1, 1, alpha)
v <- c(v, v_new)
tail <- tail * (1 - v_new)
}
v
}
update_v_given_z <- function(v, z, alpha) {
K <- length(v)
n_k <- tabulate(z, nbins = K)
n_tail <- rev(cumsum(rev(n_k)))
for(k in 1:K) {
a <- 1 + n_k[k]
b <- alpha + if(k<K) n_tail[k+1] else 0
v[k] <- rbeta(1, a, b)
}
v
}
# ------------------------ Data generation (ICM) ------------------------------
gen_icm_curves <- function(N=50, P=128, M=3, t=seq(0,1,len=P),
B = matrix(c(1,.7,.5,.7,1,.4,.5,.4,1),3,3),
eta = rep(0.02,3),
kern = kernels[[1]], par = list(l_scale=0.2)) {
Kx <- kern$fun(t, par)
K  <- kronecker_icm(B, Kx, eta)
Y  <- vector("list", N)
for(i in 1:N) {
yvec <- as.numeric(mvrnorm(1, mu=rep(0, P*M), Sigma=K + diag(1e-6, P*M)))
Y[[i]] <- matrix(yvec, nrow=P, ncol=M)
}
Y
}
# ------------------------ Initialization -------------------------------------
draw_new_cluster_params <- function(M, P, t, kern_list, wf="la8", J=NULL, boundary="periodic") {
if (is.null(J)) J <- floor(log2(P))
zeros <- matrix(0, nrow=P, ncol=M)
tmp   <- wt_forward_mat(zeros, wf=wf, J=J, boundary=boundary)
lev_names <- names(tmp[[1]]$map$idx)
ncoeff <- length(tmp[[1]]$coeff)
wpar <- lapply(1:M, function(m) {
sigma2_level <- setNames(rinvgamma(length(lev_names), 2, 1), lev_names)
list(pi=rbeta(1,1,1),
g = rinvgamma(1,2,1),
sigma2_level = sigma2_level,
gamma = rbinom(ncoeff,1,0.2))
})
thetas <- lapply(kern_list, function(kc) kc$pstar())
list(
wpar = wpar,
kern_idx = sample.int(length(kern_list),1),
thetas   = thetas,
L = diag(M),
eta = rep(0.05, M),
acc = list(kern=0, L=0, eta=0)
)
}
# ------------------------ The full driver ------------------------------------
run_model <- function(Y, t,
n_iter=6000, burn=3000, thin=5,
alpha_prior = c(1,1),
wf="la8", J=NULL, boundary="periodic",
mh_step_L=0.03, mh_step_eta=0.10) {
N <- length(Y); P <- nrow(Y[[1]]); M <- ncol(Y[[1]])
if (is.null(J)) J <- floor(log2(P))
if (abs(P - 2^J) > 0) stop("P must be 2^J (dyadic) for DWT.")
alpha <- 1.0
v     <- rbeta(1, 1, alpha)
pi    <- stick_to_pi(v)
K     <- length(v)
params <- list(draw_new_cluster_params(M, P, t, kernels, wf, J, boundary))
z      <- rep(1, N)
keep <- floor((n_iter - burn)/thin)
Z_s     <- matrix(NA_integer_, keep, N)
K_s     <- integer(keep)
alpha_s <- numeric(keep)
kern_s  <- integer(keep)
acc_hist <- data.frame(iter=integer(0), accL=double(0), accEta=double(0), accKer=double(0))
sidx <- 0
message(sprintf("Run: N=%d, P=%d, M=%d, iters=%d (burn=%d, thin=%d)", N,P,M,n_iter,burn,thin))
for(iter in 1:n_iter) {
pb <- utils::txtProgressBar(min = 1, max = n_iter, style = 3)
# ---- Walker slice: sample u, extend sticks, candidate sets --------------
pi <- stick_to_pi(v)
u  <- sapply(1:N, function(i) runif(1, 0, pi[z[i]]))
u_star <- min(u)
v <- extend_sticks_until(v, alpha, u_star)
pi <- stick_to_pi(v)
K  <- length(v)
while(length(params) < K) params[[length(params)+1]] <- draw_new_cluster_params(M,P,t,kernels,wf,J,boundary)
# ---- Assignments z_i ----------------------------------------------------
for(i in 1:N) {
S <- which(pi > u[i]); if(length(S)==0) S <- 1
logw <- rep(-Inf, length(S))
for(ss in seq_along(S)) {
k <- S[ss]
wtf <- wt_forward_mat(Y[[i]], wf=wf, J=J, boundary=boundary)
gam <- lapply(params[[k]]$wpar, function(wm) wm$gamma)
y_norm <- wt_inverse_mat_keep(Y[[i]], wtf, gam)
kc <- kernels[[ params[[k]]$kern_idx ]]
kp <- params[[k]]$thetas[[ params[[k]]$kern_idx ]]
lp <- log(pi[k])
ll <- loglik_icm(y_norm, t, params[[k]]$L, params[[k]]$eta, kc, kp)
logw[ss] <- lp + ll
}
w <- exp(logw - max(logw)); w <- w / sum(w)
z[i] <- S[sample.int(length(S), 1, prob=w)]
}
# ---- Update sticks v | z ------------------------------------------------
v <- update_v_given_z(v, z, alpha)
pi <- stick_to_pi(v)
K  <- length(v)
# ---- Per-cluster updates ------------------------------------------------
for(k in 1:K) {
idx <- which(z == k)
if(length(idx) == 0) next
Yk <- Y[idx]
# (1) Wavelet block (per-level sigma2)
upd <- update_wavelet_params(Yk, wf=wf, J=J, boundary=boundary, wpar=params[[k]]$wpar,
a_pi=1, b_pi=1, a_g=2, b_g=1, a_s=2, b_s=1, c0=1e-3)
params[[k]]$wpar <- upd$wpar
# Reconstruct normals
Yk_norm <- reconstruct_normals_for_cluster(Yk, wf=wf, J=J, boundary=boundary, wpar=params[[k]]$wpar)
# (2) Carlinâ€“Chib kernel switch
cc <- cc_switch_kernel(kernels, params[[k]]$kern_idx, params[[k]]$thetas, t, Yk_norm, params[[k]]$L, params[[k]]$eta)
params[[k]]$kern_idx <- cc$idx
params[[k]]$thetas   <- cc$thetas
# (3) MH: kernel params, L (B), eta
kc <- kernels[[ params[[k]]$kern_idx ]]
kp <- params[[k]]$thetas[[ params[[k]]$kern_idx ]]
tmp <- mh_update_kernel(kc, kp, t, Yk_norm, params[[k]]$L, params[[k]]$eta, params[[k]]$acc)
params[[k]]$thetas[[ params[[k]]$kern_idx ]] <- tmp$kp
params[[k]]$acc <- tmp$acc
tmp <- mh_update_L(params[[k]]$L, 0.03, t, Yk_norm, params[[k]]$eta, kc,
params[[k]]$thetas[[ params[[k]]$kern_idx ]], params[[k]]$acc)
params[[k]]$L   <- tmp$L; params[[k]]$acc <- tmp$acc
tmp <- mh_update_eta(params[[k]]$eta, 0.10, t, Yk_norm, params[[k]]$L, kc,
params[[k]]$thetas[[ params[[k]]$kern_idx ]], params[[k]]$acc)
params[[k]]$eta <- tmp$eta; params[[k]]$acc <- tmp$acc
# (Optional) identifiability: trace(B)=M
Bk <- tcrossprod(params[[k]]$L)
sB <- sum(diag(Bk))
if (sB > 0) {
Bk <- Bk * (length(params[[k]]$eta) / sB)
params[[k]]$L <- chol(Bk)
}
}
# ---- Update alpha (Escobarâ€“West) ---------------------------------------
Kocc <- length(unique(z))
eta_aux <- rbeta(1, alpha + 1, N)
mix <- (alpha_prior[1] + Kocc - 1) /
(N*(alpha_prior[2] - log(eta_aux)) + alpha_prior[1] + Kocc - 1)
if(runif(1) < mix) {
alpha <- rgamma(1, alpha_prior[1] + Kocc, alpha_prior[2] - log(eta_aux))
} else {
alpha <- rgamma(1, alpha_prior[1] + Kocc - 1, alpha_prior[2] - log(eta_aux))
}
# ---- Diagnostics bookkeeping -------------------------------------------
if(iter %% 50 == 0) {
occ <- sort(unique(z))
A <- sapply(occ, function(k) c(params[[k]]$acc$L, params[[k]]$acc$eta, params[[k]]$acc$kern))
if(is.matrix(A)) A <- rowMeans(A) else A <- rep(NA,3)
acc_hist <- rbind(acc_hist, data.frame(iter=iter, accL=A[1], accEta=A[2], accKer=A[3]))
for(k in occ) params[[k]]$acc <- list(kern=0, L=0, eta=0)
}
# ---- Store --------------------------------------------------------------
if(iter > burn && ((iter - burn) %% thin == 0)) {
sidx <- sidx + 1
Z_s[sidx,] <- z
K_s[sidx]  <- length(unique(z))
alpha_s[sidx] <- alpha
tab <- table(z)
k_big <- as.integer(names(which.max(tab)))
kern_s[sidx] <- params[[k_big]]$kern_idx
}
utils::setTxtProgressBar(pb, iter)
}
close(pb)
list(Z=Z_s, K=K_s, alpha=alpha_s, kern=kern_s,
acc=acc_hist, params=params, v=v, pi=stick_to_pi(v))
}
# ------------------------ Demo + Diagnostics ---------------------------------
run_big_demo <- function() {
P <- 32; M <- 3; t <- seq(0,1,len=P)
Y1 <- gen_icm_curves(N=60, P=P, M=M, t=t,
B=matrix(c(1,.85,.7,.85,1,.6,.7,.6,1),3,3),
eta=rep(0.02,3),
kern=kernels[[1]], par=list(l_scale=0.18))
Y2 <- gen_icm_curves(N=40, P=P, M=M, t=t,
B=matrix(c(1,.5,.2,.5,1,.3,.2,.3,1),3,3),
eta=rep(0.03,3),
kern=kernels[[2]], par=list(l_scale=0.08))
Y  <- c(Y1, Y2)
true_z <- c(rep(1,length(Y1)), rep(2,length(Y2)))
res <- run_model(Y, t,
n_iter=6000, burn=3000, thin=5,
wf="la8", J=log2(P), boundary="periodic",
alpha_prior=c(1,1),
mh_step_L=0.03, mh_step_eta=0.10)
par(mfrow=c(3,2), mar=c(4,4,2,1))
plot(res$K, type='s', main="Trace of K", xlab="kept iter", ylab="K")
if(length(unique(res$K))>1) {
plot(density(res$K), main="Density of K", xlab="K")
} else {
hist(res$K, main="Density of K", xlab="K", breaks=(min(res$K)-0.5):(max(res$K)+0.5))
}
plot(res$alpha, type='l', main="Trace of alpha", xlab="kept iter", ylab="alpha")
barplot(table(res$kern), main="Active-kernel (largest cluster) freq", ylab="count",
names.arg = sapply(as.integer(names(table(res$kern))), function(i) kernels[[i]]$name))
if(nrow(res$acc)>0) {
matplot(res$acc$iter, cbind(res$acc$accL, res$acc$accEta, res$acc$accKer),
type='l', lty=1, lwd=2, main="MH acceptance (moving avg)", xlab="iter", ylab="rate")
legend("bottomright", c("L (B)","eta","kernel params"), col=1:3, lty=1, bty="n")
} else {
plot.new(); title("Acceptance summary")
}
z_hat <- res$Z[nrow(res$Z),]; z_hat <- as.integer(factor(z_hat))
cm <- table(True=true_z, Found=z_hat)
plot.new(); text(0.5,0.8,"Confusion (last kept sample)"); text(0.5,0.5, paste(capture.output(print(cm)), collapse="\n"))
par(mfrow=c(1,1))
cols <- c("#1f77b4","#d62728","#2ca02c","#9467bd","#ff7f0e")
plot(NA, xlim=range(t), ylim=range(unlist(Y)), xlab="t", ylab="value", main="Clustered curves")
lab <- z_hat
for (i in 1:length(Y)) matlines(t, Y[[i]], lty=1, col=adjustcolor(cols[ lab[i] ], 0.25))
legend("topright", legend=paste("Cluster", sort(unique(lab))), col=cols[sort(unique(lab))], lty=1, bty="n")
invisible(res)
}
# ------------------------ Run the big demo -----------------------------------
res <- run_big_demo()  # Commented out to prevent automatic execution
source("C:/Users/Daniel/Desktop/ICM-R/sampler.R")
res
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler2.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
install.packages("future.apply")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
install.packages(c("foreach","doParallel"))
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
??%dopar%
??dopar
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
source("C:/Users/Daniel/Desktop/ICM-R/sampler3/sampler3_semi_supervised.R")
